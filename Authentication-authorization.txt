------------After notes (Remaining portion) :-------------
It's important to note that while authentication and authorization are often discussed as distinct steps, they work together as essential components of a security strategy to control access to resources and protect against unauthorized actions.
Now we will implement authentication as a middleware function so that routes will be authenticated before reaching out to server.
Implementing authentication as a middleware function is a common and effective approach.

------------Passport.js------------
Passport.Js is a popular authentication middleware for node js. Authentication is the process of verifying the identity of a user, typically through a username and password, before granting access to certain resources or features on a website or application.
Think of passport.js as a helpful tool that makes it easier for developers to handle user authentication in their node.js applications. It simplifies the process of authenticating users by providing a set of pre-built strategies for different authentication methods such as username and password, social media logins like Facebook or Google and more.
Here's a breakdown of some key concepts in passport.js :-
1. Middleware: In the context of web development, middleware is software that sits between the application and the server. Passport.js acts as a middleware intercepting requests and adding authentication-related functionality to them.
2. Strategy: passport.Js uses the concept of strategies for handling different authentication methods. A strategy is a way of authenticating users. Passport.js comes with various built-in strategies and you can also create custom strategies to specific authentication providers.
3. Serialize and deserialize: passport.js provides methods for serializing and deserializing userdata. Serialization is the process of converting user data into a format that can be stored usually as a unique identifier. Deserialisation is the reverse process of converting that unique identifier back into user data.These processes are essential for managing user sessions.

-------------> Install passport ------------
To use passport.JS in a Node.js application, you need to install the passport package along with the authentication strategies you intend to use. Here, we are using local strategies authentication (username and password).
You would typically install passport-local
npm install passport passport-local
Once you have installed these packages you can set up and configure passport properties in your application.
// ... code ...

-------------> Passport local strategy ------------
The passport local strategy is a part of the passport.JS authentication middleware for node.js. It's specifically designed for handling username and password-based authentication.
The passport local strategy, by default, extract the username and password from the request body. It is a common practice for username and password-based authentication systems to send the credentials as part of the request body, especially in login forms.

-------------> Add username and password ------------
Now we have to add username and password in the person schema.
// ... code added ...
but previous records of person don't have username and password, so they will not be able to login
new people can login

-------------> Configure the Local Strategy ------------
Define and configure the local strategy using passport-local.
You need to provide a verification function that checks the provided username and password
// ... code ...
In the local strategy's verification function, you typically query your database to find the user with the provided username. You then compare the provided password with the stored password.
In the context of LocalStrategy, passport.Js expects the verification function to have the following signature:
function(username, password, done)
The done callback should always be the last parameter, and it's essential to maintain this order for passport.js to work correctly, if you change the order of parameters, you risk breaking the expected behaviour of Passport.js

In the context of Passport.js, done is a callback function that is provided by Passport to signal the completion of an authentication attempt. It is used to indicate whether the authentication was successful, and if so, to provide information about the authenticated user.
The done function taks 3 parameters: done(error, user, info)
If the authentication is successful, you call done(null, user) where user is an object representing the authenticated user.
If the authentication fails, you call done(null, false, {message: 'some message'}). The second parameter (false) indicates that authentication 
// ... code ...
In code {session: false}, but localStrategy is made to implement along with session
so in Postman:-
under Authorization => even after entering correct username and passowrd, there is Bad Request
under Params => after entering correct username and passowrd, authentication gets successfully completed and url becomes -> localhost:3000/?username=jay123&password=iamjay123

------------ Store Plain Password ------------
Storing plain passwords is not a secure practice. To enhance security, it's highly recommended to hash and salt passwords before storing them.
... diagram ...

You can use ## bcrypt ## library for password hashing in your Node.js application
npm install bcrypt --save
Bcrypt: ... diagram ...

------------ Password hash Salting: ... diagram ...
Now we have to update our person model to store hashed passwords. Modify the registration logic to hash the password before saving it to the database.
Because the end user did not know about hashing, we have to internally maintain it. Like we are saving the hashed password before saving it into the database.
We are using a Mongoose middleware hook to perform and action before saving a document to the database. Specifically its using the ## pre ## middleware to execute function before the ## save ## operation in database.

... code ...
The ## pre('save', ...) ## middleware is triggered before the ## save ## operation on the mongoose model instance.
Inside the middleware function, it checks if the password field has been modified (or if its a new document). If not, it skips the hashing process.
If the password has been modified, it generates a new salt using ## bcrypt.genSalt ## and then hashes the password using ## bcrypt.hash ##
The original plain text password in the ## person ## document is then replaced with the hashed password.
The ## next() ## function is called to proceed with the same operation

The line const salt = await brypt.genSalt(10) is responsible for generating a salt, which is a random string of characters used as an additional input to the password hashing function.
Salting is a crucial step in password hashing to prevent attackers from using precomputed tables (rainbow tables) to quickly look up the hash value of a password
brcypt.genSalt(rounds): This function generates a salt using the specified number of "rounds". The "Rounds" parameter indicates the complexity of the hashing algorithm. The higher the number of rounds, the more the secure the salt, but it also increases the computational cost.

if(!person.isModified('password')) return next()

This line is a conditional check that prevents unncessary rehashing of the password when the document is being saved.

person.isModified('password') : This method is provided by Mongoose and returns true if the specified field ('password' in this case) has been modified. It returns false if the field has not been modified. 
return next() : If the password field has not been modified, the function immediately returns, skipping the rest of the middleware, this is because there is no need to rehash the password if it has not changed.

------------ How bcrypt works ------------
When you use bcrypt to hash a password, the library internally stores the salt as part of the resulting hashed password. This means that you don't need to separately store the salt in your database; it is included in the hashed password itself.
Here's a simplified explanation of how it works:
1. Hashing a password: 
When you hash a password using bcrypt.hash, the library generates a random salt, hashes the password along with the salt, and produces a hashed password that incorporates both the salt and the hashed value.

const salt = await bcrypt.genSalt(10)
const hashPassword = await bcrypt.hash('userpassword', salt)

The ##hashedPassword## now contains both the ###hashed password and the salt###

------------ Modify Auth Code ------------
We also have to modify the password-matching logic in the passport auth file
Lets create a comparePassword named function which compares or check the passowrd.
... code ...

------------ Compare function ------------
We also have to write the compare function
... code ...

When you later want to verify a user's entered password during login, you use bcrypt.compare. This function internally extracts the salt from the stored hashed password and uses it to hash the entered password for comparison.

const isMatch = await brcypt.compare('enteredPassword', storedHashedPassword)

The compare function automatically extracts the salt from storedHashedPassword and uses it to hash the entered password, it then compares the resulting hash with the stored hash. If they match, it indicates that the entered password is correct.